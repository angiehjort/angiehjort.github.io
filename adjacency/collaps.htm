<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .nodeV, .nodeH {cursor: pointer;}
    * {
        font: 10px sans-serif;
    }
    text:hover {
        font-size: 12px;
        font-weight: bold;
    }
    line {stroke-width: 3px;}
    line:hover {stroke-width: 7px;}
    div.tooltip{opacity: 0; background-color: #d1d89a;  position: absolute; font-size: 14px}
    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 1.5px;
    }
</style>

<body>
    <script src="d3.v3.min.js"></script>
    <script>
        var margin = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 20
            },
            width = 960 - margin.right - margin.left,
            height = 960 - margin.top - margin.bottom;

        var i = 0,
            duration = 750,
            leaves,
            heightOne,
            rules,
            root;

        var tree = d3.layout.cluster().separation(function(a, b){return 1})
            .size([height, width]);

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom);
        var svgV = svg.append("g").attr("transform", "translate(" + margin.left + "," + (margin.top+200) + ")");
        var svgH = svg.append("g").attr("transform", "translate(" + (margin.left+200) + "," + margin.top + ")");
        var linksSvg = svg.append("g").attr("transform", "translate(" + (margin.left+200) + "," + (margin.top+200) + ")");
        var tooltip = d3.select("body").append("div").attr("class","tooltip");

        d3.json("readme.json", function (error, flare) {
            root = flare;
            leaves = getLeaves(root);
            root.x0 = height / 2;
            root.y0 = 0;

            heightOne = height/leaves.length;

            //collapse everything starting from d and down the hierarchy
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }

            //call collapsing of the entire tree
            //root.children.forEach(collapse);
            d3.json("rules.json", function (error, parsed){
                rules = parsed;
                update(root);
                updatematrix(rules.links);
            });
        });



        d3.select(self.frameElement).style("height", "800px");


        function getLeaves(d) {
            var result = [];
                if (d.children) {
                    for (var i in d.children) result = result.concat(getLeaves(d.children[i]))
                    return result;
                }else{
                    return [d.id];
                }
        }

        function getFirstLeaveY(d) {
            return d.children ? getFirstLeaveY(d.children[0]) : d.x;
        }

        function getLastLeaveY(d) {
            return d.children ? getLastLeaveY(d.children[d.children.length-1]) : d.x;
        }

        function updatematrix (links){
            var linksRect = linksSvg.selectAll("circle.links").data(links);

            linksRect.enter().append("circle").attr("class","links").on("mouseover",tooltipON).on("mouseout",tooltipOFF);
            linksRect.exit().remove();

            linksRect.transition().duration(duration)
                .attr("cy", function(d){return leaves.indexOf(d.if)*heightOne })
                .attr("cx", function(d){return leaves.indexOf(d.then)*heightOne})
                .attr("r", function(d){return heightOne/2})
                .style("opacity", function(d){
                    if(leaves.indexOf(d.if)==-1|| leaves.indexOf(d.then) ==-1) return 0;
                    return d.confidence
                });

        }

        function tooltipON(d) {
            d3.select("div.tooltip").style("opacity",0.9)
                .html(d.if + " → " + d.then + " <br> " + "confidence: " + d.confidence + " <br> " + "hits: " + d.hits)
                .style("top",d3.event.y+10+"px")
                .style("left",d3.event.x+10+"px")
                ;

        }

        function tooltipOFF(d) {
            d3.select("div.tooltip").style("opacity",0)
            .style("top",0)
            .style("left",0);
        }


        function update(source) {

            leaves = getLeaves(root);

            // Compute the new tree layout.
            var nodes = tree.nodes(root).reverse();

            // Normalize for fixed-depth.
            nodes.forEach(function (d) { d.y = d.depth * 25; });

            // Update the nodes…
            var nodeV = svgV.selectAll("g.nodeV")
                .data(nodes, function (d) { return d.id || (d.id = ++i);  });
            var nodeH = svgH.selectAll("g.nodeH")
                .data(nodes, function (d) { return d.id || (d.id = ++i);  });

            // Enter any new nodes at the parent's previous position.
            var nodeEnterV = nodeV.enter().append("g")
                .attr("class", "nodeV")
                .attr("transform", function (d) {return "translate(" + source.y0 + "," + source.x0 + ")"; })
                .on("click", click);
            var nodeEnterH = nodeH.enter().append("g")
                .attr("class", "nodeH")
                .attr("transform", function (d) {return "translate(" + source.x0 + "," + source.y0 + ")"; })
                .on("click", click);

            nodeEnterV.append("line")
                .attr("x1", 0)
                .attr("x2", 0)
                .style("stroke", function (d) { return d._children ? "green" : "grey"; });
            nodeEnterH.append("line")
                .attr("y1", 0)
                .attr("y2", 0)
                .style("stroke", function (d) { return d._children ? "green" : "grey"; });

            nodeEnterV.append("text")
                .text(function (d) { return d.id;})
                .style("fill-opacity", 1e-6);
            nodeEnterH.append("text")
                .text(function (d) { return d.id;})
                .style("fill-opacity", 1e-6);

            // Transition nodes to their new position.
            var nodeUpdateV = nodeV.transition()
                .duration(duration)
                .attr("transform", function (d) {  return "translate(" + d.y + "," + d.x + ")"; });
            var nodeUpdateH = nodeH.transition()
                .duration(duration)
                .attr("transform", function (d) {  return "translate(" + d.x + "," + d.y + ")"; });

            nodeUpdateV.select("line")
                .attr("y1", function (d) {return getFirstLeaveY(d) - d.x - heightOne/3})
                .attr("y2", function (d) {return getLastLeaveY(d) - d.x + heightOne/3})
                .style("stroke", function (d) {return d._children ? "green" : "grey";});
            nodeUpdateH.select("line")
                .attr("x1", function (d) {return getFirstLeaveY(d) - d.x - heightOne/3})
                .attr("x2", function (d) {return getLastLeaveY(d) - d.x + heightOne/3})
                .style("stroke", function (d) {return d._children ? "green" : "grey";});

            nodeUpdateV.select("text")
                .attr("transform", function (d) { return "rotate("+ (d.children?-90:0) +")";})
                .attr("x", function (d) {return d.children?0:10;})
                .attr("dy", function (d) { return d.children?-10:".35em";})
                .attr("text-anchor", function (d) { return d.children?"middle":"start";})
                .style("fill-opacity", 1);
            nodeUpdateH.select("text")
                .attr("transform", function (d) { return "rotate("+ (d.children?0:-90) +")";})
                .attr("x", function (d) {return d.children?0:-10;})
                .attr("dy", function (d) { return d.children?-10:".35em";})
                .attr("text-anchor", function (d) { return d.children?"middle":"end";})
                .style("fill-opacity", 1);



            // Transition exiting nodes to the parent's new position.
            var nodeExitV = nodeV.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + source.y + "," + source.x + ")"; })
                .remove();
            var nodeExitH = nodeH.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + source.x + "," + source.y + ")"; })
                .remove();

            nodeExitV.select("line")
                .attr("y1", 0)
                .attr("y2", 0);
            nodeExitH.select("line")
                .attr("y1", 0)
                .attr("y2", 0);

            nodeExitV.select("text")
                .style("fill-opacity", 1e-6);
            nodeExitH.select("text")
                .style("fill-opacity", 1e-6);



            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            updatematrix(rules.links);
        }

         // Toggle children on click.
        function click(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }
    </script>
