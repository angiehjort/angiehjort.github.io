<!DOCTYPE html>
<meta charset="utf-8">
<style>

    text, div {font: 10px Verdana, sans-serif; fill: grey; }

    .grid{stroke: #ebebeb; stroke-width: 1px;}
    .grid.hover{stroke: #b9b9b9; stroke-width: 1px;}

    .node {cursor: pointer;}
    .node line {stroke-width: 3px; }
    .node.hover line {stroke-width: 7px;}
    .node.hover text {font-size: 12px; font-weight: bold; fill: black;}
    .node.leaf text {fill: lightgrey;}

    .link {
        cursor: pointer;
        pointer-events: visible;
        fill: none;
        stroke: #008600;
        stroke-width: 1.5px;
    }
    .link.hover {fill: #008600;}

    div.tooltip{opacity: 0; background-color: #d1d89a;  position: absolute; font-size: 14px}
</style>

<body>
    <script src="d3.v3.min.js"></script>
    <script src="utilities.js"></script>
    <script src="jquery-2.1.1.js"></script>
    <script src="moment.min.js"></script>
    <script src="picker.js"></script>
    <script src="picker.date.js"></script>
    <script>
        var screenSize = Math.min(window.innerWidth, window.innerHeight);
        var margin = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 20
            },
            square = {w: 200, h: 200},
            width = screenSize - margin.right - margin.left,
            height = screenSize - margin.top - margin.bottom;

        var i = 0,
            duration = 1000,
            leaves,
            heightOne,
            linksOriginal,
            linksVisible,
            linksAffected,
            globalRoot;

        var tree = d3.layout.cluster().separation(function(a, b){return 1})
            .size([height - square.h, width - square.w]);

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom);
        var gridSvg = svg.append("g").attr("transform", "translate(" + (margin.left+square.w) + "," + (margin.top+square.h) + ")");
        var svgV = svg.append("g").attr("transform", "translate(" + margin.left + "," + (margin.top+square.h) + ")");
        var svgH = svg.append("g").attr("transform", "translate(" + (margin.left+square.w) + "," + margin.top + ")");
        var linksSvg = svg.append("g").attr("transform", "translate(" + (margin.left+square.w) + "," + (margin.top+square.h) + ")");
        var tooltip = d3.select("body").append("div").attr("class","tooltip");

        d3.json("readme.json", function (error, flare) {
            globalRoot = flare;
            leaves = getLeaves(globalRoot);
            globalRoot.x0 = height / 2;
            globalRoot.y0 = 0;

            heightOne = (height-square.h)/leaves.length;

            //collapse everything starting from d and down the hierarchy
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }

            //call collapsing of the entire tree
            //globalRoot.children.forEach(collapse);
            d3.json("rules.json", function (error, parsed){
                linksOriginal = parsed.links;
                linksVisible = linksOriginal;
                linksAffected = getLinksByNode(linksVisible, globalRoot);
                updateTree(globalRoot);
            });
        });



        d3.select(self.frameElement).style("height", "800px");


        function getLeaves(d) {
            var result = [];
            if (d.children==null)return[d];
            for (var i in d.children) result = result.concat(getLeaves(d.children[i]))
            return result;
        }

        function getLeavesEvenHidden(d) {
            var result = [];
            if (d.children==null && d._children==null)return [d];

            if (d.children) {
                for (var i in d.children) result = result.concat(getLeavesEvenHidden(d.children[i]))
            }
            if (d._children) {
                for (var i in d._children) result = result.concat(getLeavesEvenHidden(d._children[i]))
            }
            return result;
        }


        function getFirstLeaveY(d) {
            return d.children ? getFirstLeaveY(d.children[0]) : d.x;
        }

        function getLastLeaveY(d) {
            return d.children ? getLastLeaveY(d.children[d.children.length-1]) : d.x;
        }

        function tooltipON(d) {
            d3.select("div.tooltip").style("opacity",0.9)
                .html(d.if + " â†’ " + d.then + " <br> " + "confidence: " + d.confidence + " <br> " + "hits: " + d.hits)
                .style("top",d3.event.y+10+"px")
                .style("left",d3.event.x+10+"px");
                d3.selectAll(".vertical.id" + d.if).classed("hover",true);
                d3.selectAll(".horizontal.id" + d.then).classed("hover",true);
                d3.select(".link.id" + d.if + d.then).classed("hover",true);
        }
        function tooltipOFF(d) {
            d3.select("div.tooltip").style("opacity",0)
                .style("top",0)
                .style("left",0);
                d3.selectAll(".vertical.id" + d.if).classed("hover",false);
                d3.selectAll(".horizontal.id" + d.then).classed("hover",false);
                d3.select(".link.id" + d.if + d.then).classed("hover",false);
        }
        function hoverNodeON(node){
            d3.selectAll(".vertical.id" + node.id).classed("hover",true);
            d3.selectAll(".horizontal.id" + node.id).classed("hover",true);
            getLinksByNode(linksVisible, node).forEach(function(l){
                d3.selectAll(".link.id" + l.if + l.then).classed("hover",true);
            })
        }
        function hoverNodeOFF(node){
            d3.selectAll(".vertical.id" + node.id).classed("hover",false);
            d3.selectAll(".horizontal.id" + node.id).classed("hover",false);
            getLinksByNode(linksVisible, node).forEach(function(l){
                d3.selectAll(".link.id" + l.if + l.then).classed("hover",false);
            })
        }

        function getNodeByNodeID(id){
            return nodes.filter(function(d){return d.id==id})[0];
        }
        function getLinksByNode(linksArray, node, inIfs, inThens, includeNestedNodes){
            //defaults
            if (inIfs==null)inIfs=true;
            if (inThens==null)inThens=true; //by default
            if (includeNestedNodes==null)includeNestedNodes=true; //by default

            if (includeNestedNodes){
                var result = [];
                getLeavesEvenHidden(node).forEach(function(n){
                    log(n)
                    result = result.concat(
                        linksArray.filter(function(d){return inIfs && d.if==n.id || inThens && d.then==n.id})
                    );
                });
                return arrayUnique(result);
            }else{
                return linksArray.filter(function(d){return inIfs && d.if==n.id || inThens && d.then==n.id});
            }
        }

        function order(a, b){return a.hits - b.hits; }

        function updatematrix (root){

            // remode all the affected links
            linksVisible = linksVisible.filter(function(d){
                // filter OK when linksAffected does not contain the current d in linksVisible
                return linksAffected.map(function(dd){return JSON.stringify(dd)}).indexOf(JSON.stringify(d))==-1
            });

            // for every affected leaf node in IF
            getLeaves(globalRoot).forEach(function(leaf_If){
                // for every affected leaf node in THEN
                getLeaves(globalRoot).forEach(function(leaf_Then){

                    var leafHidden_If = getLeavesEvenHidden(leaf_If).map(function(d){return d.id});
                    var leafHidden_Then = getLeavesEvenHidden(leaf_Then).map(function(d){return d.id});



                    var linksToAggregate = linksAffected.filter(function(l){
                        return leafHidden_If.indexOf(l.if)!=-1 && leafHidden_Then.indexOf(l.then)!=-1;
                    })

                    var newLink = {if: leaf_If.id, then: leaf_Then.id, hits:0, confidence:0};

                    linksToAggregate.forEach(function(l){
                        newLink.hits += l.hits;
                        newLink.confidence += l.confidence*l.hits;
                    });
                    newLink.confidence /= newLink.hits;

                    if(linksToAggregate.length)linksVisible.push(newLink);

                });

            });


            console.log("affected", linksAffected.map(function(d){return d.hits}))
            console.log("visible", linksVisible.map(function(d){return d.hits}))



            var linksRect = linksSvg.selectAll("circle.link").data(linksVisible.sort(order));
            linksRect.exit().transition().duration(duration)
                .attr("cy", root.x)
                .attr("cx", root.x)
                .attr("r", 0)
                .style("opacity", 0)
                .remove();


            linksRect.enter().append("circle")
                .attr("class",function(d){return "link id" + d.if + d.then})
                .attr("cy", root.x)
                .attr("cx", root.x)
                .attr("r", 0)
                .style("opacity", 0)
                .on("mouseover",tooltipON)
                .on("mouseout",tooltipOFF);


            linksRect.transition().duration(duration)
                .attr("cy", function(d){return leaves.indexOf(d.if)*heightOne + heightOne/2})
                .attr("cx", function(d){return leaves.indexOf(d.then)*heightOne + heightOne/2})
                .attr("r", function(d){return Math.sqrt(d.hits)/2})
                .style("opacity", function(d){return d.confidence})
                .sort(order);


        }


        function updateTree(root) {

            var leavesObj = getLeaves(globalRoot);
            leaves = leavesObj.map(function(d){return d.id});

            // Compute the new tree layout.
            nodes = tree.nodes(globalRoot).reverse();

            // Normalize for fixed-depth.
            nodes.forEach(function (d) { d.y = d.depth * 25; });

            // Bind the data
            var nodeV = svgV.selectAll("g.node.vertical")
                .data(nodes, function (d) { return d.id || (d.id = ++i);  });
            var nodeH = svgH.selectAll("g.node.horizontal")
                .data(nodes, function (d) { return d.id || (d.id = ++i);  });


            log(leavesObj.length)
            var gridV = gridSvg.selectAll("line.grid.vertical").data(leavesObj);
            var gridH = gridSvg.selectAll("line.grid.horizontal").data(leavesObj);

            // Enter any new nodes at the parent's position and build the views
            var nodeEnterV = nodeV.enter().append("g")
                .attr("class", function(d){return "node vertical id"+d.id})
                .attr("transform", function (d) {return "translate(" + root.y0 + "," + root.x0 + ")"; })
                .on("click", click)
                .on("mouseover", hoverNodeON)
                .on("mouseout", hoverNodeOFF);
            var nodeEnterH = nodeH.enter().append("g")
                .attr("class", function(d){return "node horizontal id"+d.id})
                .attr("transform", function (d) {return "translate(" + root.x0 + "," + root.y0 + ")"; })
                .on("click", click)
                .on("mouseover", hoverNodeON)
                .on("mouseout", hoverNodeOFF);

            nodeEnterV.append("line")
                .attr("x1", 0)
                .attr("x2", 0)
                .style("stroke", function (d) { return d._children ? "red" : "grey"; });
            nodeEnterH.append("line")
                .attr("y1", 0)
                .attr("y2", 0)
                .style("stroke", function (d) { return d._children ? "red" : "grey"; });

            nodeEnterV.append("text")
                .text(function (d) { return d.id;})
                .style("fill-opacity", 1e-6);
            nodeEnterH.append("text")
                .text(function (d) { return d.id;})
                .style("fill-opacity", 1e-6);

            gridV.enter().append("line")
                .attr("class", function(d){return "grid vertical id"+d.id})
                .attr("x1", 0).attr("x2", width - square.w)
                .attr("y1", height).attr("y2", height)
                .attr("stroke-dasharray", "2,1");

            gridH.enter().append("line")
                .attr("class", function(d){return "grid horizontal id"+d.id})
                .attr("y1", 0).attr("y2", height  - square.h)
                .attr("x1", width).attr("x2", width)
                .attr("stroke-dasharray", "2,1");


            // Transition nodes to their new position.
            var nodeUpdateV = nodeV.transition()
                .duration(duration)
                .attr("transform", function (d) {  return "translate(" + d.y + "," + d.x + ")"; });
            var nodeUpdateH = nodeH.transition()
                .duration(duration)
                .attr("transform", function (d) {  return "translate(" + d.x + "," + d.y + ")"; });

            nodeUpdateV.select("line")
                .attr("y1", function (d) {return getFirstLeaveY(d) - d.x - heightOne/3})
                .attr("y2", function (d) {return getLastLeaveY(d) - d.x + heightOne/3})
                .style("stroke", function (d) {return d._children ? "red" : "grey";});
            nodeUpdateH.select("line")
                .attr("x1", function (d) {return getFirstLeaveY(d) - d.x - heightOne/3})
                .attr("x2", function (d) {return getLastLeaveY(d) - d.x + heightOne/3})
                .style("stroke", function (d) {return d._children ? "red" : "grey";});

            nodeUpdateV.select("text")
                .attr("transform", function (d) { return "rotate("+ (d.children?-90:0) +")";})
                .attr("x", function (d) {return d.children?0:10;})
                .attr("dy", function (d) { return d.children?-10:".35em";})
                .attr("text-anchor", function (d) { return d.children?"middle":"start";})
                .style("fill-opacity", 1);
            nodeUpdateH.select("text")
                .attr("transform", function (d) { return "rotate("+ (d.children?0:-90) +")";})
                .attr("x", function (d) {return d.children?0:-10;})
                .attr("dy", function (d) { return d.children?-10:".35em";})
                .attr("text-anchor", function (d) { return d.children?"middle":"end";})
                .style("fill-opacity", 1);

            gridV.transition().duration(duration)
                .attr("y1", function(d){return d.x})
                .attr("y2", function(d){return d.x});
            gridH.transition().duration(duration)
                .attr("x1", function(d){return d.x})
                .attr("x2", function(d){return d.x});

            // Transition the removed nodes to the parent's new position.
            var nodeExitV = nodeV.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + root.y + "," + root.x + ")"; })
                .remove();
            var nodeExitH = nodeH.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + root.x + "," + root.y + ")"; })
                .remove();

            nodeExitV.select("line").style("fill-opacity", 1e-6);
            nodeExitH.select("line").style("fill-opacity", 1e-6);
            nodeExitV.select("text").style("fill-opacity", 1e-6);
            nodeExitH.select("text").style("fill-opacity", 1e-6);
            gridV.exit().transition().duration(duration)
                .attr("y1", height).attr("y2", height).remove();
            gridH.exit().transition().duration(duration)
                .attr("x1", width).attr("x2", width).remove();


            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            updatematrix(root);
        }

         // Toggle children on click.
        function click(root) {
            // get all the links that are affected and need update
            linksAffected = getLinksByNode(linksVisible, root);

            if (root.children) {
                root._children = root.children;
                root.children = null;
            } else {
                root.children = root._children;
                root._children = null;
            }
            updateTree(root);
        }
    </script>
