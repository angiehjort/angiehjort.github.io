<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .node {cursor: pointer;}
    * {
        font: 10px Verdana, sans-serif;
        fill: grey;
    }
    text:hover, g.hover text {font-size: 12px; font-weight: bold; fill: black;}
    .node.leaf text {fill: lightgrey;}

    line {stroke-width: 3px; }
    line:hover {stroke-width: 7px;}
    div.tooltip{opacity: 0; background-color: #d1d89a;  position: absolute; font-size: 14px}
    .link {
        cursor: pointer;
        pointer-events: visible;
        fill: none;
        stroke: #000;
        stroke-width: 1.5px;
    }
    .link:hover {fill: #000;}

</style>

<body>
    <script src="d3.v3.min.js"></script>
    <script src="utilities.js"></script>
    <script src="jquery-2.1.1.js"></script>
    <script src="moment.min.js"></script>
    <script src="picker.js"></script>
    <script src="picker.date.js"></script>
    <script>
        var margin = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 20
            },
            width = 960 - margin.right - margin.left,
            height = 960 - margin.top - margin.bottom;

        var i = 0,
            duration = 1000,
            leaves,
            heightOne,
            linksOriginal,
            linksVisible,
            globalRoot;

        var tree = d3.layout.cluster().separation(function(a, b){return 1})
            .size([height, width]);

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom);
        var svgV = svg.append("g").attr("transform", "translate(" + margin.left + "," + (margin.top+200) + ")");
        var svgH = svg.append("g").attr("transform", "translate(" + (margin.left+200) + "," + margin.top + ")");
        var linksSvg = svg.append("g").attr("transform", "translate(" + (margin.left+200) + "," + (margin.top+200) + ")");
        var tooltip = d3.select("body").append("div").attr("class","tooltip");

        d3.json("readme.json", function (error, flare) {
            globalRoot = flare;
            leaves = getLeaves(globalRoot);
            globalRoot.x0 = height / 2;
            globalRoot.y0 = 0;

            heightOne = height/leaves.length;

            //collapse everything starting from d and down the hierarchy
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }

            //call collapsing of the entire tree
            //globalRoot.children.forEach(collapse);
            d3.json("rules.json", function (error, parsed){
                linksOriginal = parsed.links;
                linksVisible = linksOriginal;
                updateTree(globalRoot);
            });
        });



        d3.select(self.frameElement).style("height", "800px");


        function getLeaves(d) {
            var result = [];
            if (d.children==null)return[d];
            for (var i in d.children) result = result.concat(getLeaves(d.children[i]))
            return result;
        }

        function getLeavesEvenHidden(d) {
            var result = [];
            if (d.children==null && d._children==null)return [d];

            if (d.children) {
                for (var i in d.children) result = result.concat(getLeavesEvenHidden(d.children[i]))
            }
            if (d._children) {
                for (var i in d._children) result = result.concat(getLeavesEvenHidden(d._children[i]))
            }
            return result;
        }


        function getFirstLeaveY(d) {
            return d.children ? getFirstLeaveY(d.children[0]) : d.x;
        }

        function getLastLeaveY(d) {
            return d.children ? getLastLeaveY(d.children[d.children.length-1]) : d.x;
        }

        function tooltipON(d) {
            d3.select("div.tooltip").style("opacity",0.9)
                .html(d.if + " â†’ " + d.then + " <br> " + "confidence: " + d.confidence + " <br> " + "hits: " + d.hits)
                .style("top",d3.event.y+10+"px")
                .style("left",d3.event.x+10+"px");
                d3.select("g.vertical.id" + getNodeByNodeID(d.if).id).classed("hover",true);
                d3.select("g.horizontal.id" + getNodeByNodeID(d.then).id).classed("hover",true);
        }
        function tooltipOFF(d) {
            d3.select("div.tooltip").style("opacity",0)
                .style("top",0)
                .style("left",0);
                d3.select("g.vertical.id" + getNodeByNodeID(d.if).id).classed("hover",false);
                d3.select("g.horizontal.id" + getNodeByNodeID(d.then).id).classed("hover",false);
        }
        function getNodeByNodeID(id){
            return nodes.filter(function(d){return d.id==id})[0];
        }
        function getLinksByNode(node, inIfs, inThens, includeNestedNodes){
            //defaults
            if (inIfs==null)inIfs=true;
            if (inThens==null)inThens=true; //by default
            if (includeNestedNodes==null)includeNestedNodes=true; //by default

            if (includeNestedNodes){
                var result = [];
                getLeavesEvenHidden(node).forEach(function(n){
                    result = result.concat(
                        linksOriginal.filter(function(d){return inIfs && d.if==n.id || inThens && d.then==n.id})
                    );
                });
                return arrayUnique(result);
            }else{
                return linksOriginal.filter(function(d){return inIfs && d.if==n.id || inThens && d.then==n.id});
            }
        }

        function order(a, b){return a.hits - b.hits; }

        function updatematrix (root){
//            // get all the links that are affected and need update
//            var linksAffected = getLinksByNode(root);
//            // remode all the affected links
//            linksVisible = linksVisible.filter(function(d){
//                // filter OK when linksAffected does not contain the current d in linksVisible
//                return linksAffected.map(function(dd){return JSON.stringify(dd)}).indexOf(JSON.stringify(d))==-1
//            });
//
//            // for every affected leaf node in IF
//            getLeaves(globalRoot).forEach(function(leaf_If){
//                // for every affected leaf node in THEN
//                getLeaves(globalRoot).forEach(function(leaf_Then){
//
//                    var leafHidden_If = getLeavesEvenHidden(leaf_If).map(function(d){return d.id});
//                    var leafHidden_Then = getLeavesEvenHidden(leaf_Then).map(function(d){return d.id});
//
//
//
//                    var linksToAggregate = linksAffected.filter(function(l){
//                        return leafHidden_If.indexOf(l.if)!=-1 && leafHidden_Then.indexOf(l.then)!=-1;
//                    })
//
//                    var newLink = {if: leaf_If.id, then: leaf_Then.id, hits:0, confidence:0};
//
//                    linksToAggregate.forEach(function(l){
//                        newLink.hits += l.hits;
//                        newLink.confidence += l.confidence*l.hits;
//                    });
//                    newLink.confidence /= newLink.hits;
//
//                    if(linksToAggregate.length)linksVisible.push(newLink);
//
//                });
//
//            });
//
//
//            console.log("affected", linksAffected.map(function(d){return d.hits}))
//            console.log("visible", linksVisible.map(function(d){return d.hits}))
//


            var linksRect = linksSvg.selectAll("circle.link").data(linksVisible.sort(order));
            linksRect.exit().transition().duration(duration)
                .attr("cy", root.x)
                .attr("cx", root.x)
                .attr("r", 0)
                .style("opacity", 0)
                .remove();


            linksRect.enter().append("circle")
                .attr("class","link")
                .attr("cy", root.x)
                .attr("cx", root.x)
                .attr("r", 0)
                .style("opacity", 0)
                .on("mouseover",tooltipON)
                .on("mouseout",tooltipOFF);


            linksRect.transition().duration(duration)
                .attr("cy", function(d){return leaves.indexOf(d.if)*heightOne + heightOne/2})
                .attr("cx", function(d){return leaves.indexOf(d.then)*heightOne + heightOne/2})
                .attr("r", function(d){return Math.sqrt(d.hits)/2})
                .style("opacity", function(d){return d.confidence})
                .sort(order);


        }


        function updateTree(root) {

            leaves = getLeaves(globalRoot).map(function(d){return d.id});

            // Compute the new tree layout.
            nodes = tree.nodes(globalRoot).reverse();

            // Normalize for fixed-depth.
            nodes.forEach(function (d) { d.y = d.depth * 25; });

            // Bind the data
            var nodeV = svgV.selectAll("g.node.vertical")
                .data(nodes, function (d) { return d.id || (d.id = ++i);  });
            var nodeH = svgH.selectAll("g.node.horizontal")
                .data(nodes, function (d) { return d.id || (d.id = ++i);  });

            // Enter any new nodes at the parent's position and build the views
            var nodeEnterV = nodeV.enter().append("g")
                .attr("class", function(d){return "node vertical id"+d.id})
                .attr("transform", function (d) {return "translate(" + root.y0 + "," + root.x0 + ")"; })
                .on("click", click);
            var nodeEnterH = nodeH.enter().append("g")
                .attr("class", function(d){return "node horizontal id"+d.id})
                .attr("transform", function (d) {return "translate(" + root.x0 + "," + root.y0 + ")"; })
                .on("click", click);

            nodeEnterV.append("line")
                .attr("x1", 0)
                .attr("x2", 0)
                .style("stroke", function (d) { return d._children ? "green" : "grey"; });
            nodeEnterH.append("line")
                .attr("y1", 0)
                .attr("y2", 0)
                .style("stroke", function (d) { return d._children ? "green" : "grey"; });

            nodeEnterV.append("text")
                .text(function (d) { return d.id;})
                .style("fill-opacity", 1e-6);
            nodeEnterH.append("text")
                .text(function (d) { return d.id;})
                .style("fill-opacity", 1e-6);

            // Transition nodes to their new position.
            var nodeUpdateV = nodeV.transition()
                .duration(duration)
                .attr("transform", function (d) {  return "translate(" + d.y + "," + d.x + ")"; });
            var nodeUpdateH = nodeH.transition()
                .duration(duration)
                .attr("transform", function (d) {  return "translate(" + d.x + "," + d.y + ")"; });

            nodeUpdateV.select("line")
                .attr("y1", function (d) {return getFirstLeaveY(d) - d.x - heightOne/3})
                .attr("y2", function (d) {return getLastLeaveY(d) - d.x + heightOne/3})
                .style("stroke", function (d) {return d._children ? "green" : "grey";});
            nodeUpdateH.select("line")
                .attr("x1", function (d) {return getFirstLeaveY(d) - d.x - heightOne/3})
                .attr("x2", function (d) {return getLastLeaveY(d) - d.x + heightOne/3})
                .style("stroke", function (d) {return d._children ? "green" : "grey";});

            nodeUpdateV.select("text")
                .attr("transform", function (d) { return "rotate("+ (d.children?-90:0) +")";})
                .attr("x", function (d) {return d.children?0:10;})
                .attr("dy", function (d) { return d.children?-10:".35em";})
                .attr("text-anchor", function (d) { return d.children?"middle":"start";})
                .style("fill-opacity", 1);
            nodeUpdateH.select("text")
                .attr("transform", function (d) { return "rotate("+ (d.children?0:-90) +")";})
                .attr("x", function (d) {return d.children?0:-10;})
                .attr("dy", function (d) { return d.children?-10:".35em";})
                .attr("text-anchor", function (d) { return d.children?"middle":"end";})
                .style("fill-opacity", 1);

            // Transition the removed nodes to the parent's new position.
            var nodeExitV = nodeV.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + root.y + "," + root.x + ")"; })
                .remove();
            var nodeExitH = nodeH.exit().transition()
                .duration(duration)
                .attr("transform", function (d) { return "translate(" + root.x + "," + root.y + ")"; })
                .remove();

            nodeExitV.select("line")
                .attr("y1", 0)
                .attr("y2", 0);
            nodeExitH.select("line")
                .attr("y1", 0)
                .attr("y2", 0);

            nodeExitV.select("text")
                .style("fill-opacity", 1e-6);
            nodeExitH.select("text")
                .style("fill-opacity", 1e-6);



            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            updatematrix(root);
        }

         // Toggle children on click.
        function click(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            updateTree(d);
        }
    </script>
