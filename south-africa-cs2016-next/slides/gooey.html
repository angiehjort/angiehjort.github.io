<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/ >
	<title>Gooey Effect</title>

	<script src="../lib/d3.v3.min.js"></script>
	<script src="../lib/topojson.v1.min.js"></script>
	<!-- jQuery -->
	<script src="../lib/jquery.min.js"></script>
	<style>

	@font-face {
	  font-family: 'geoslab703_md_bt_medium';
	  src: url('../assets/fonts/geoslab703_md_bt_medium.woff2') format('woff2'),
	       url('../assets/fonts/geoslab703_md_bt_medium.woff') format('woff'),
	       url('../assets/fonts/geoslab703_md_bt_medium.ttf') format('truetype');
	}
	@font-face {
	  font-family: 'geo703mi';
	  src: url('../assets/fonts/geo703mi.woff2') format('woff2'),
	       url('../assets/fonts/geo703mi.woff') format('woff'),
	       url('../assets/fonts/geo703mi.ttf') format('truetype');
	}
	@font-face {
	  font-family: 'cargts';
	  src: url('../assets/fonts/cargts.woff2') format('woff2'),
	       url('../assets/fonts/cargts.woff') format('woff'),
	       url('../assets/fonts/cargts.ttf') format('truetype');
	}


	.subunit-boundary {
	  fill: none;
	  stroke: #fff;
	  stroke-width: 1;
	}
	.mun-boundary {
	  fill: none;
	  stroke: #fff;
	  stroke-width: 0.5;
	}
	.municipality {
		fill: #ffd044 ;
	}

	#tooltipwrapper {
	    position: absolute;	
	    top: 0%;
	    left: 10%;
	}
	#tooltipwrapper>span {
		font-family: 'geoslab703_md_bt_medium';
		font-size: 7vh;
		font-weight: bold;
		display: block;
		margin-bottom: 10px;
	}
	.tooltip {							
	    font: 12px sans-serif;		
	    background: #ffdb7a;	
	    border: 0px;		
	    border-radius: 5px;			
	    pointer-events: none;
	    padding: 20px;
	    padding-top: 25px;
	    min-width: 260px;
	    line-height: 1.2em;		
	}

	.tooltip span {
		font-size: 20px;
		display: block;
		padding-bottom: 5px;
		font-family: 'cargts';
	}
	.tooltip {
		font-family: 'geoslab703_md_bt_medium';
		font-size: 5vh;
	}

	* {
		padding: 0; 
		margin: 0;
	}

	html,
	body,
	.chart, 
	.chart svg {
		width: 100%;
		height: 100%;
		overflow: hidden;
	}

	#buttons {
		font-family: "Trebuchet MS";
	}
	#buttons a {
		color: #e9b434 ;
		text-decoration: none;
		cursor: pointer;
		font-size: 2vh;
		line-height: 4vh;
		display: inline-block;
	}
	#buttons a:hover {
		color: #888;
	}

	.province1 { fill: red; }
	.province2 { fill: green; }
	.province3 { fill: #6c77ff; }
	.province4 { fill: #444; }
	.province5 { fill: #009189; }
	.province6 { fill: white; }
	.province7 { fill: #910000; }
	.province8 { fill: purple; }
	.province9 { fill: #000b88; }

	.centerCircle { fill: #ffdb7a  ;}

</style>
</head>
<body onkeyup="parent.keyCode(event)">

<div id="tooltipwrapper">
	<div id="buttons">
		<a href="#" id="link">National</a>
		<a href="#" id="prov">Provincial</a>
		<a href="#" id="mun">Municipal</a>
	</div>
	<span>Population</span>
	<div class="tooltip"><span>South Africa</span></div>
</div>
	<div class="chart"></div>
	
	<script>


	////////////////////////////////////////////////////////////// 
	//////////////////////// Initiate //////////////////////////// 
	////////////////////////////////////////////////////////////// 

	var w = window,
		d = document,
		e = d.documentElement,
		g = d.getElementsByTagName('body')[0];
	
	var margin = {top: 10, left: 10, bottom: 10, right: 10}
	  , width = w.innerWidth || e.clientWidth || g.clientWidth
	  , width = width - margin.left - margin.right
	  , height = w.innerHeight || e.clientHeight || g.clientHeight
	  , height = height - margin.top - margin.bottom - 10
	  , mapratio = 1.138439624240457
	
	if (width > (height * mapratio))	
		width = height * mapratio; // height 100%
	else
		height = width / mapratio; // width 100%
	


	//Create SVG
	var svg = d3.select(".chart").append("svg");
	var municipalities = svg.append("g").attr("class", "municipalities");
	var provinces = svg.append("g").attr("class", "provinces")
	var bubbles = svg.append("g").attr("class", "bubbles");
		//.style("filter", "url(#gooey)"); //Set the filter on the container svg
	var centerCircle;
	var centerCirclePos;
		//.attr("transform", "translate(" + (width/2 + margin.left) + "," +(height/2 +  margin.top) + ")");

 	//SVG filter for the gooey effect
	//Code taken from http://tympanus.net/codrops/2015/03/10/creative-gooey-effects/
	var defs = bubbles.append('defs');
	var filter = defs.append('filter').attr('id','gooey');
	filter.append('feGaussianBlur')
		.attr('in','SourceGraphic')
		.attr('stdDeviation','10')
		.attr('result','blur');
	filter.append('feColorMatrix')
		.attr('in','blur')
		.attr('mode','matrix')
		.attr('values','1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7')
		.attr('result','gooey');
	filter.append('feComposite')
		.attr('in','SourceGraphic')
		.attr('in2','gooey')
		.attr('operator','atop');	
	
	// create filter with id #drop-shadow
	// height=130% so that the shadow is not clipped
	var filter2 = defs.append("filter")
	    .attr("id", "dropshadow")
	    .attr("height", "150%")
	    .attr("width", "150%")
	    .attr("x", "-40%")
	    .attr("y", "-40%");

	// SourceAlpha refers to opacity of graphic that this filter will be applied to
	// convolve that with a Gaussian with standard deviation 3 and store result
	// in blur
	filter2.append("feGaussianBlur")
	    .attr("in", "SourceAlpha")
	    .attr("stdDeviation", 2)
	    .attr("result", "blur");

	// translate output of Gaussian blur to the right and downwards with 2px
	// store result in offsetBlur
	filter2.append("feOffset")
	    .attr("in", "blur")
	    .attr("dx", 1)
	    .attr("dy", 1)
	    .attr("result", "offsetBlur");

	// overlay original SourceGraphic over translated blurred opacity by using
	// feMerge filter. Order of specifying inputs is important!
	var feMerge = filter2.append("feMerge");

	feMerge.append("feMergeNode")
	    .attr("in", "offsetBlur")
	feMerge.append("feMergeNode")
	    .attr("in", "SourceGraphic");


	var projection = d3.geo.mercator()
	    .center([24, -29])
	    .scale(width*3)	
	    .rotate([0,0,0])
	    .translate([width / 2, height / 2]);

    svg
      .attr('viewBox', "0 0 "+width+" "+height)
      .attr('preserveAspectRatio', 'xMidYMid');   

	var path = d3.geo.path()
		.projection(projection);

	// Define the div for the tooltip
	var tooltip = d3.select(".tooltip");

	var popDict;
	var sizeScale;
	var mundata, provdata;
    var prIdLookup, mnIdLookup;

	// load map
      
    var PR_SA_2011 = "topo";
    var MN_SA_2011 = "topo";
      
	d3.json("../maps/provinces.json", function(prov_error, sa_prov) {
		d3.json("../maps/municipalities.json", function(mun_error, sa_mun) {
			d3.csv('../data/ddf--datapoints--population--by--geo.csv', function(pop_error, pop) {
			  	if (prov_error) return console.error(prov_error);
			  	if (pop_error)  return console.error(pop_error);

			  	provdata = topojson.feature(sa_prov, sa_prov.objects[PR_SA_2011]).features
			  	mundata	= topojson.feature(sa_mun, sa_mun.objects[MN_SA_2011]).features;
                
                prIdLookup = sa_prov.objects.id_lookup;
                mnIdLookup = sa_mun.objects.id_lookup;
              
				provinces.selectAll(".province")
				    .data(provdata)
				    .enter().insert("path", ":first-child")
				      .attr("class", function(d) { return "province " + d.properties[prIdLookup]; })
				      .attr("id", function(d) { return "province" + d.properties[prIdLookup]; })
				      .attr("d", path)
				      .style("opacity", 0);
				
				centerCirclePos = path.centroid(topojson.merge(sa_prov, sa_prov.objects[PR_SA_2011].geometries));
				
				svg.insert("path", ".bubbles")
				      .datum(topojson.mesh(sa_prov, sa_prov.objects[PR_SA_2011], function(a, b) { return a !== b }))
				      .attr("d", path)
				      .attr("class", "subunit-boundary");

				svg.insert("path", ".bubbles")
				      .datum(topojson.mesh(sa_mun, sa_mun.objects[MN_SA_2011], function(a, b) { return a !== b }))
				      .attr("d", path)
				      .attr("class", "mun-boundary");

				municipalities.selectAll(".municipality")
				    .data(mundata)
				    .enter().insert("path", ":first-child")
				      .attr("class", function(d) { return "municipality " + d.properties[mnIdLookup]; })
				      .attr("id", function(d) { return "municipality" + d.properties[mnIdLookup]; })
				      .attr("d", path);

				popDict = process_popdata(pop);

					// pop -> bubble size scale
				sizeScale = d3.scale.linear()
				    .domain([0, popDict[0]])
				    .range([1, 20]);
    

			  	console.log(sa_prov, sa_mun, popDict);

				//drawBubbles(popDict);
			});
		});
	});


    function process_popdata(pop) {
    	var popDict = {};
    	pop.forEach(function(d) { popDict[d.geo] = d.population });
    	return popDict;
    }

    $('#link').on('click', function() {

		// Create national pop circle
		bubbles.selectAll(".centerCircle").data([{ pop: popDict[0], name: 'South Africa'}]).enter().append("circle")
				.attr("class", "centerCircle")
				.attr("cx", centerCirclePos[0])
				.attr("cy", centerCirclePos[1])
				.attr("r", '0%')
				.transition("national")
					.duration(1500)
					.attr("r", sizeScale(popDict[0]) + '%');
		centerCircle = d3.select(".centerCircle");

		centerCircle.style("filter", "url(#dropshadow)");

		tooltip.html('<span>South Africa</span>'+formatter(popDict[0]));
		return false;
    });

    $('#prov').on('click', function() {

		//Create the circles that will move out and in the center circle
		var steps = 9;	
		bubbles.selectAll(".flyCircle")
			.data(d3.range(steps).map(function(num) {
				var provinceID = num+1;
				var provNode = provinces.select("#province"+provinceID).data()[0];
				return {
					id: provinceID,
					latlng: path.centroid(provNode),
					pop: popDict[provinceID],
					name: provNode.properties.PR_NAME
				}
			}))
			.enter().insert("circle", ":first-child")
				.attr("class", function(d) { return "flyCircle province"+ d.id; })
				.attr("id", function(d) { return "provinceCircle" + d.id })
				.attr("cx", centerCirclePos[0])
				.attr("cy", centerCirclePos[1])
				.style("filter", "url(#dropshadow)")
				.attr("r", function(d) { 
					return sizeScale(d.pop) + '%'; })
				.call(function() {
					update('.flyCircle', '.centerCircle', 4000);
				});	
		return false;
    });

    $('#mun').on('click', function() {

    	var munPerProv = {};
    	mundata.forEach(function(mun) {
    		if (!munPerProv[mun.properties.PR_CODE]) munPerProv[mun.properties.PR_CODE] = [];
    		munPerProv[mun.properties.PR_CODE].push(mun);
    	})

			// pop -> bubble size scale
		munScale = d3.scale.log()
		    .domain([7000, 3442361])
		    .range([0.2, 2.5]);

		//Create the circles that will move out and in the center circle

		Object.keys(munPerProv).forEach(function(provID) {
			var prov = munPerProv[provID];
			var numGeo = prov.length;
			var centerlatlng = path.centroid(provinces.select("#province"+provID).data()[0]);
			var centerX = (width/2 + margin.left);
			var centerY = (height/2 + margin.top);

			bubbles.selectAll(".munCircleProv"+provID)
				.data(d3.range(numGeo).map(function(num) {
					var geoID = prov[num].properties.MN_CODE;
					var munNode = municipalities.select("#municipality"+geoID).data()[0];
					return {
						latlng: path.centroid(munNode),
						pop: popDict[geoID],
						name: munNode.properties.MN_NAME
					}
				}))
				.enter().append("circle")
					.attr("class", "munCircle munCircleProv"+provID+" province"+provID)
					.style("opacity", 0.8)
					.attr("cx", centerlatlng[0])
					.attr("cy", centerlatlng[1])
					.attr("r", function(d) { return munScale(d.pop) + '%'; })
					.call(function() {
						update(".munCircleProv"+provID, "#provinceCircle"+provID);
					});

		});
		return false;
    });

	//Continuously moves the circles outward and inward
	function update(circleClass, sourceCircleClass, totaldur) {
			var circle = d3.selectAll(circleClass);
			totaldur = totaldur || 5000;
			var dur = 1500,
				del = (totaldur-dur)/circle.size();

			var offsetx = width/2;
			var offsety = height/2;
				

			addToolTip(circle);

			circle
				.transition("outward").duration(dur).delay(function(d,i) { return i*del; })
					.attr("cx", function(d) { return d.latlng[0]; })
					.attr("cy", function(d) { return d.latlng[1]; });	
			
			var decreaseDuration = circle.size()*del + dur;

				//.transition("inward").duration(dur).delay(function(d,i) { return steps*del + i*del; })
				//	.attr("cx", centerX)
				//	.attr("cy", centerY)	


			d3.selectAll(sourceCircleClass)
				.transition().duration(decreaseDuration)
					.attr("r", '0%')
	}//update	


	function addToolTip(circle) {
		circle
			.on("mouseover", function(d) {		
	            tooltip.html('<span>' + d.name + "</span>"+formatter(d.pop))		
	         });			
	}
	
    function formatter(x){

        // Strings, null, NaN and undefined are bypassing any formatter
        if(x instanceof String || !x && x!==0) return x;

        if(Math.abs(x)<0.00000000000001) return "0";

        var format = "r"; //rounded format. use "f" for fixed
        var prec = 3; //round to so many significant digits

        var prefix = "";

        //---------------------
        // BEAUTIFIERS GO HOME!
        // don't break formatting please
        //---------------------
        // the tiny constant compensates epsilon-error when doing logsrithms
        switch(Math.floor(Math.log(Math.abs(x))/Math.LN10 + 0.00000000000001)) {
          case -13: x = x * 1000000000000; prefix = "p"; break; //0.1p
          case -10: x = x * 1000000000; prefix = "n"; break; //0.1n
          case -7: x = x * 1000000; prefix = "µ"; break; //0.1µ
          case -6: x = x * 1000000; prefix = "µ"; break; //1µ
          case -5: x = x * 1000000; prefix = "µ"; break; //10µ
          case -4: break; //0.0001
          case -3: break; //0.001
          case -2: break; //0.01
          case -1: break; //0.1
          case 0:  break; //1
          case 1:  break; //10
          case 2:  break; //100
          case 3:  break; //1000
          case 4:  x = x / 1000; prefix = "k"; break; //10k
          case 5:  x = x / 1000; prefix = "k"; break; //100k
          case 6:  x = x / 1000000; prefix = "M"; break; //1M
          case 7:  x = x / 1000000; prefix = "M"; break; //10M
          case 8:  x = x / 1000000; prefix = "M"; break; //100M
          case 9:  x = x / 1000000000; prefix = "B"; break; //1B
          case 10: x = x / 1000000000; prefix = "B"; break; //10B
          case 11: x = x / 1000000000; prefix = "B"; break; //100B
          case 12: x = x / 1000000000000; prefix = "TR"; break; //1TR
          case 13: x = x / 1000000000000; prefix = "TR"; break; //10TR
          case 14: x = x / 1000000000000; prefix = "TR"; break; //100TR
          //use the D3 SI formatting for the extreme cases
          default: return(d3.format("." + prec + "s")(x)).replace("G", "B");
        }

        var formatted = d3.format("." + prec + format)(x);
        //remove trailing zeros if dot exists to avoid numbers like 1.0M, 3.0B, 1.500, 0.9700, 0.0
        if (formatted.indexOf(".")>-1) formatted = formatted.replace(/0+$/,"").replace(/\.$/,"");

        // use manual formatting for the cases above
        return(formatted + prefix);
    }

	</script>
  </body>
</html>